clear;
clc;

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% define border
% east=[641741.2712 641741.2712 641772.0256 641772.0256];
% north=[3606786.5921 3606861.6984 3606861.6984 3606786.5921];

east=[741 741 752 752];
north=[786 790 790 786];


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% Settings
pathSpeed=0.75;    % speed to run path at (m/s)
MinRadius=5;    % min distance between passes
Spacing=1;      % 
Direction=1;    % 1 - run north-south
                % 2 - run east-west

if Direction==1
    % generate equation for line defining starting boundary
    Ms=(north(4)-north(1))/(east(4)-east(1));
    Bs=north(1)-Ms*east(1);
    % generate equation for line defining ending boundary
    Me=(north(3)-north(2))/(east(3)-east(2));
    Be=north(2)-Me*east(2);

    % calculate width of field
    %widths(1)=sqrt((north(3)-north(2))^2+(east(3)-east(2))^2);
    width=sqrt((north(4)-north(1))^2+(east(4)-east(1))^2);
    %width=widths(max(widths));
    % calculate number of passes needed
    number=floor(width/Spacing);
elseif Direction==2
    % generate equation for line defining starting boundary
    % check for infinite slope
    if (north(4)-north(1))==0
        Ms=0;
    else
        Ms=(east(4)-east(1))/(north(4)-north(1));
    end
    Bs=east(1)-Ms*north(1);

    % generate equation for line defining ending boundary
    if ((north(3)-north(2))==0)
        Me=0;
    else
        Me=(east(3)-east(2))/(north(3)-north(2));
    end
    Be=east(3)-Me*north(3);

    % calculate width of field
    %widths(1)=sqrt((north(3)-north(2))^2+(east(3)-east(2))^2);
    width=sqrt((north(2)-north(1))^2+(east(2)-east(1))^2);
    %width=widths(max(widths));
    % calculate number of passes needed
    number=floor(width/Spacing);
    
end
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% allocate memory for arrays
startPoints(number+1).E=0;
startPoints(number+1).N=0;
endPoints(number+1).E=0;
endPoints(number+1).N=0;
% wE(number)=0;
% wN(number)=0;
% 
% generate points along both lines at distance given in Spacing
for i=1:number+1
    if Direction==1
        % Generate point on bottom (starting) line
        % move Spacing to the east
        startPoints(i).E=east(1)+(i-1)*Spacing;
        % find North coordinate using equation for line (N=Ms*E+Bs)
        startPoints(i).N=Ms*startPoints(i).E+Bs;

        % Generate point on top (ending) line
        % move Spacing to the east
        endPoints(i).E=east(1)+(i-1)*Spacing;
        % find North coordinate using equation for line (N=Me*E+Be)
        endPoints(i).N=Me*endPoints(i).E+Be;
    elseif Direction==2
        % Generate point on bottom (starting) line
        % move Spacing to the north
        startPoints(i).N=north(1)+(i-1)*Spacing;
        % find east coordinate using equation for line (E=Ms*N+Bs)
        startPoints(i).E=Ms*startPoints(i).N+Bs;

        % Generate point on top (ending) line
        % move Spacing to the east
        endPoints(i).N=north(1)+(i-1)*Spacing;
        % find North coordinate using equation for line (E=Me*N+Be)
        endPoints(i).E=Me*endPoints(i).N+Be;
    end
end

% determine order of points based on min turn radius

nextPoint=1;   % current top point
curWaypoint=1; % current waypoint number
dir=-1;
%for i=1:60
for i=1:number+1
    % add one line segment to path
  % determine what side of field last point was on to pick next point
  if (mod(i-1,11)==0)
      dir=dir*-1;
  end
 
    if (mod(i,2)==1)
       % on bottom of field 
       wE(curWaypoint)=startPoints(nextPoint).E;
       wN(curWaypoint)=startPoints(nextPoint).N;
       curWaypoint=curWaypoint+1;
       wE(curWaypoint)=endPoints(nextPoint).E;
       wN(curWaypoint)=endPoints(nextPoint).N;
       curWaypoint=curWaypoint+1;
       if dir==1
           nextPoint=nextPoint+MinRadius+1;
       else
           nextPoint=nextPoint-MinRadius;
       end
    else
       % on top of field
       wE(curWaypoint)=endPoints(nextPoint).E;
       wN(curWaypoint)=endPoints(nextPoint).N;
       curWaypoint=curWaypoint+1;
       wE(curWaypoint)=startPoints(nextPoint).E;
       wN(curWaypoint)=startPoints(nextPoint).N;
       curWaypoint=curWaypoint+1;
       if dir==1
           nextPoint=nextPoint-MinRadius;
       else
           nextPoint=nextPoint+MinRadius+1; 
       end
    end
end

figure(1);
clf;
hold on
scatter(east(1),north(1),'r^');
scatter(east(2),north(2),'b^');
scatter(east(3),north(3),'g^');
scatter(east(4),north(4),'k^');
%scatter(east,north,'r^');
scatter([startPoints.E],[startPoints.N],'gs');
scatter([endPoints.E],[endPoints.N],'ys');
hold off

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% Plot gnerated path
speed=pathSpeed*ones(1,length(wE));

waypoints=[wE' wN'];
path=WaypointsToRSPath(waypoints, 15,speed);
hold on
% scatter(east,north)

axes_num=gca;
plot_linetracker_path(path, axes_num,'RS',0,''); % draw arcs and lines that represent path
axis equal


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%Generate Path File
fid = fopen('c:\GeneratedPath.txt','w');
for i=1:length(path.heading)
    fprintf(fid,'%f %f 0.75 \r\n',path.end.E(i),path.end.N(i));
end
fclose(fid);
 


