%-----------------------------------------------------------
% Calculate_Errors - Line Tracker
% Calculates heading, yaw rate, and lateral error given a
% vehicle state and a path defined as a sequence of lines
% and arcs
%
% Syntax: line_tracker_calculate_errors(vehicle_state, path, mode)
%
% Path structure:
%   .center.E[]
%   .center.N[]
%   .end.E[]
%   .end.N[]
%   .ccw[]
%   .heading[]
%   .speed[]
%
% Error/Output structure:
%   .mode
%   .psi.error
%   .psi.desired
%   .y.error
%   .r.error
%   .r_desired
%   .waypoint_index
%
% Vehicle state structure
%   .steer
%   .yaw_rate
%   .speed
%   .long_accel
%   .course
%   .north
%   .east
%-----------------------------------------------------------

function error_struct=line_tracker_calculate_errors_test(vehicle_state, path, mode)
%-----------------------------------------------------------
% TODO LIST
%   - CHANGE PATH STRUCTURE TO MAKE CENTER AND END ARRAYS
%     INSTEAD OF E AND N
%   - DERIVE EQUATION TO CALCULATE DESIRED HEADING WHEN
%     ON AN ARC
%-----------------------------------------------------------

%-----------------------------------------------------------
% setup persistent value to store last waypoint selected
% once a waypoint has been passed, the search for the next
% waypoint begins after it
persistent previous_waypoint;
previous_waypoint;
if isempty(previous_waypoint==0)
    previous_waypoint=2;
end
%-----------------------------------------------------------


%-----------------------------------------------------------
% Find desired waypoint
% Criteria:
%   - select first endpoint that is in front of the vehicle that has not
%     been driven to yet
error_struct.waypoint_index=2;
method='closest';
%method='once-only';
switch(method)

    case 'closest'

        min_distance=999999;

        for i=2:length(path.end.E)
            % check to see if waypoint is behind vehicle
            %    psi=atan2((waypoints(i,1)-vehicle_state.east),(waypoints(i,2)-vehicle_state.north));
            desired=CheckWrap(atan2((path.end.E(i)-vehicle_state.east),path.end.N(i)-vehicle_state.north));
            %     error=CheckWrap(abs(vehicle_state.course-desired));
            error=CheckWrap(desired-vehicle_state.course);
            if abs(error)<(pi/2)
                %check to see if waypoint is inside radius
                distance=sqrt((vehicle_state.north-path.end.N(i))^2+(vehicle_state.east-path.end.E(i))^2);
                if (distance<min_distance)
                    error_struct.waypoint_index=i;
                    min_distance=distance;
                end
            end
        end

    case 'once-only'

        for i=previous_waypoint:length(path.end.E)

            % desired = desired heading to drive to current endpoint
            desired=CheckWrap(atan2((path.end.E(i)-vehicle_state.east),path.end.N(i)-vehicle_state.north));
            % error = change in current heading required to drive to current endpoint
            error=CheckWrap(desired-vehicle_state.course);

            % check to see if endpoint is behind vehicle - behind vehicle
            % if heading error is greater than 180 deg or pi/2
            if abs(error)<(pi/2)
                error_struct.waypoint_index=i;
                break;
            end
        end

end
i=error_struct.waypoint_index;
%-----------------------------------------------------------

%-----------------------------------------------------------
% Calculate desired values

%determine if current segment is line or arc
% - line if current center is equal to previous endpoint
% - arc otherwise

% calculate either arc radius or line segment length
R=sqrt((path.end.E(i)-path.center.E(i))^2+(path.end.N(i)-path.center.N(i))^2);
if ((abs(path.center.E(i)-path.end.E(i-1))<0.01) & (abs((path.center.N(i)-path.end.N(i-1)))<0.01)) % vehicle is on line segment
    error_struct.mode=0;
    % calculate desired heading(psi)
    error_struct.psi_desired=CheckWrap(atan2((path.end.E(i)-path.end.E(i-1)),path.end.N(i)-path.end.N(i-1)));

    % calculate desired yaw rate(r)
    error_struct.r_desired=0;
    error_struct.y_error=((path.end.E(i)-path.end.E(i-1))*(vehicle_state.north-path.end.N(i-1))-(path.end.N(i)-path.end.N(i-1))*(vehicle_state.east-path.end.E(i-1)))/R;    % from rob's c code
else % vehicle is on arc segment
    error_struct.mode=1;
    % get arc angle values from path structure
    theta_total=path.theta_total(i);
    theta_min=path.theta_min(i);
    theta_max=path.theta_max(i);
    % get radius of current segment
    R=path.radius(i);
    
    % try new way of calculating heading error - only works for arcs
    % - find line between center and vehicle position, and calculate its
    %   heading
    heading_temp=atan2(((vehicle_state.east-path.center.E(i))),(vehicle_state.north-path.center.N(i)));

    switch mode
        case 'RS'
            % calculate desired heading
            % - desired heading is normal to line between center point and
            % vehicle location (heading_temp is heading of that line)
            error_struct.psi_desired=CheckWrap(heading_temp+pi/2);

            % calculate desired yaw rate(r)
            error_struct.r_desired = vehicle_state.speed/R;

            % calculate lateral error
            error_struct.y_error=R-sqrt((vehicle_state.east-path.center.E(i))*(vehicle_state.east-path.center.E(i))+(vehicle_state.north-path.center.N(i))*(vehicle_state.north-path.center.N(i)));

            % fix sign on y_error to what makes sense
            error_struct.y_error=-error_struct.y_error;

        case 'SPP'
            heading_temp=mod(heading_temp+2*pi,2*pi);   % make sure heading_temp is between 0 and 360

            theta=mod(heading_temp+2*pi-theta_min,2*pi); % make sure theta is between 0 and 360

            % fix problems with arc being selected before vehicle is
            % actually past last waypoint
            % - causes heading_temp to be smaller than theta_min because
            %   vehicle is not actually on arc yet
            % - fix by assuming vehicle is at beginning of arc -NOT SURE IF THIS IS THE
            %   BEST WAY????
            if theta>theta_total
                theta=0;  % assume heading_temp = theta_min so theta=0
            end

            % calculate radius of spp arc at given angle theta
            spp.r=R*(1+theta^2/2-theta^3/theta_total+theta^4/(2*theta_total^2));
            % lateral error is difference in distance from car to center of
            % arc (d) and distance from arc to center of arc (r)
            d=sqrt((vehicle_state.east-path.center.E(i))*(vehicle_state.east-path.center.E(i))+(vehicle_state.north-path.center.N(i))*(vehicle_state.north-path.center.N(i)));
            error_struct.y_error=d-spp.r;

            % --------------calculate desired heading--------------
            % calculate derivative of arc
            spp.dr=R*theta-(3*R/theta_total)*theta^2+(2*R/theta_total^2)*theta^3;
            % calculate second derivative
            spp.dr2=R-6*R*theta/theta_total+6*R*theta^2/(theta_total^2);
            error_struct.psi_desired=CheckWrap(atan2(spp.dr*sin(heading_temp)+spp.r*cos(heading_temp),spp.dr*cos(heading_temp)-spp.r*sin(heading_temp)));
            % calculate curvature
            spp.K=(spp.r^2+2*spp.dr^2-spp.r*spp.dr2)/((spp.r^2+spp.dr^2)^(3/2));
            error_struct.r_desired=vehicle_state.speed*spp.K;
    end

    % change signs on everything for arcs that go ccw
    if (path.ccw(i)==1)
        error_struct.psi_desired=CheckWrap(error_struct.psi_desired-pi);
        error_struct.y_error=-error_struct.y_error;
        error_struct.r_desired=-error_struct.r_desired;
    end


end
%-----------------------------------------------------------
% calculate heading error(psi)
error_struct.psi_error = CheckWrap(error_struct.psi_desired-vehicle_state.course);
% calcualte yar rate error(r)
error_struct.r_error = error_struct.r_desired-vehicle_state.yaw_rate;
%-----------------------------------------------------------

end