% RS_path_headings  - calculates final orientation at each
%                     waypoint of an RS path
% 
% Method: - determines whether each segment is a line or arc segment
%         - ending heading for line segment is the same as the beginning
%           heading
%         - for arc segments, determine which way to draw arc to match
%           headings at the beginning of the arc, and calculate the angle at
%           the end
%         - generates theta_min and theta_max to be used by error
%           calculation function
%         - also adds boolean to path structure to indicate direction an
%           arc should be drawn
function out=RS_path_headings(path);

% calculate initial heading
path.heading(1)=atan2(path.end.E(2)-path.end.E(1),path.end.N(2)-path.end.N(1));
% initial segment must be a line
path.theta_min(1)=0;
path.theta_max(1)=0;
path.ccw(1)=2;  % ccw = 2 indicates a line segment

for i=2:length(path.end.E)
    % determine if points describe line or arc
    %   - section if a line if the beginning waypoint and center are the
    %     same point (or very close)
    %   - a section is an arc if the beginning waypoint and center are not he same point
    if ((abs(path.end.E(i-1)-path.center.E(i))<0.01)&(abs(path.end.N(i-1)-path.center.N(i))<0.01))
        % section is a line
        path.heading(i)=path.heading(i-1);  % start and end orientations are the same for a line
        path.theta_min(i)=0;
        path.theta_max(i)=0;
        path.ccw(i)=2;  % ccw = 2 indicates a line segment
    else    %segment is an arc
        % method:
        %   - calculate beginning and ending angles of arc
        %   - don't know which way arc should be drawn, ex: from theta_min
        %     to theta_max or from theta_max to theta_min
        %   - assume arc goes from theta_min to theta_max and check to see
        %     if heading matches previous heading
        %   - if not swap theta_min and theta_max
        
        % caclulate angle from center to beginning waypoint
        theta_min=atan2(path.end.E(i-1)-path.center.E(i),path.end.N(i-1)-path.center.N(i));
        % calculate angle from center to ending waypoint
        theta_max=atan2(path.end.E(i)-path.center.E(i),path.end.N(i)-path.center.N(i));
        % check for zero angles
        if abs(theta_min)<1e-2
            theta_min =0;
        end
        if abs(theta_max)<1e-2
            theta_max =0;
        end
        
        
        % change to all positive angles( 0 to 360 instead of -180 to 180)
        theta_min=mod(theta_min+2*pi,2*pi);
        theta_max=mod(theta_max+2*pi,2*pi);
        
        % determine if headings agree at beginning point of arc
        % calculate heading of arc - arc heading is perpendicular to arc
        % beginning angle theta_min.
        arc_heading=mod(theta_min+pi/2,2*pi);
        % check to see if angle difference is less than 10 degrees, should
        % be 180 degrees if it needs to be flipped
        if (abs(arc_heading-path.heading(i-1))>(10*pi/180));
            temp=theta_min;
            theta_min=theta_max;
            theta_max=temp;
            % segment was flipped
            path.ccw(i)=1;
            % calculate heading at end of arc
            path.heading(i)=mod(theta_min-pi/2,2*pi);
        else
            % calculate heading at end of arc
            path.heading(i)=mod(theta_max+pi/2,2*pi);
            % segment was not flipped
            path.ccw(i)=0;
        end

        % check to see if there will be a wrap problem
        % - example: theta_min = 315 degrees, theta_max=0 degrees
        % - linspace will generate 315...310...90...0 (goes in wrong
        %   direction)
        % - change 0 degrees to 360 degrees to fix
        if (theta_min>theta_max)
            theta_max=theta_max+2*pi;
        end

        % calculate total turn angle of arc
        theta_total=mod(theta_max-theta_min+2*pi,2*pi);    % total turn angle of arc

        % calculate radius of arc
        path.radius(i)=sqrt((path.end.E(i)-path.center.E(i))^2+(path.end.N(i)-path.center.N(i))^2);  %determine radius
        
        % add calculated angles to path structure
        path.theta_min(i)=theta_min;
        path.theta_max(i)=theta_max;
        path.theta_total(i)=theta_total;
    end
end
%path.heading=path.heading';
out = path;

end
