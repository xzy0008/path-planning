% plot_linetracker_path   Plots Linetracker Paths
%
% - plots a Reeds and Shepp's Path, which consists of line segments and
%   circular arcs
%  (or)
% - plots a SPP plath which consists of single polar-polynomial arcs or
%   polar splines
%
% Inputs:
% - path - a path structure which contains e,n coordinates for waypoints
%          and center points as well as the vehicle's speed for each segment
%          (speed is not used by this method)
% - axes_num - handle to axes to plot path on
% - type - 'RS' for a Reeds and Shepp's Path (or)
%        - 'SPP' for a single polar polynomial path

function fig=plot_linetracker_path_old(path, axes_num, plot_type)

beta=0.9; % break angle in radians (only used for SPP paths)

axes(axes_num);
%cla;
hold on
% draw endpoints and centers
plot(path.end.E,path.end.N,'rx')
plot(path.center.E,path.center.N,'bo')

for i=2:length(path.end.E)
    % determine if points describe line or arc
    %   - section if a line if the beginning waypoint and center are the
    %     same point (or very close)
    %   - a section is an arc if the beginning waypoint and center are not he same point
    if ((abs(path.end.E(i-1)-path.center.E(i))<0.01)&(abs(path.end.N(i-1)-path.center.N(i))<0.01))
        % section is a line
        type(i)='l';

        % generate line between previous waypoint and new waypoint

        % check to see if line will be vertical
        if (path.end.E(i)==path.end.E(i-1)) % line is vertical
            prev.E(1:100)=path.end.E(i-1)*ones(1,100);
            prev.N(1:100)=linspace(path.end.N(i-1),path.end.N(i));
        else % line is not vertical
            prev.E(1:100)=linspace(path.end.E(i-1),path.end.E(i));
            m=(path.end.N(i)-path.end.N(i-1))/(path.end.E(i)-path.end.E(i-1));
            b=path.end.N(i)-m*path.end.E(i);
            prev.N(1:100)=m.*prev.E+b;
        end
        hold on;
        plot(prev.E,prev.N);

    else
        % section is an arc
        R=sqrt((path.end.E(i)-path.center.E(i))^2+(path.end.N(i)-path.center.N(i))^2);  %determine radius

        % method:
        %   - calculate beginning and ending angles of arc
        %   - don't know which way arc should be drawn, ex: from theta_min
        %     to theta_max or from theta_max to theta_min
        %   - guess one way
        %   - calculate angle to point on path just before new segment
        %   - if calculated angle is between theta_min and theta_max, draw
        %     the other way

        % caclulate angle from center to beginning waypoint
        theta_min=atan2(path.end.E(i-1)-path.center.E(i),path.end.N(i-1)-path.center.N(i));
        % calculate angle from center to ending waypoint
        theta_max=atan2(path.end.E(i)-path.center.E(i),path.end.N(i)-path.center.N(i));
        % change to all positive angles( 0 to 360 instead of -180 to 180)
        theta_min=mod(theta_min+2*pi,2*pi);
        theta_max=mod(theta_max+2*pi,2*pi);

        theta=linspace(theta_min,theta_max,100);    % generates 100 equally spaced ponts between theta_min and theta_max

        % compute angle to point on previous segment
        theta_prev=mod(atan2(prev.E(98)-path.center.E(i),prev.N(98)-path.center.N(i))+2*pi,2*pi);

        % generate points to draw arc with
        prev.E(1:100)=path.center.E(i)+R*sin(theta);
        prev.N(1:100)=path.center.N(i)+R*cos(theta);

        % check to see if previous angle is between theta_min and theta_max
        % if so change the direction the arc is being drawn
        if (((theta_min<theta_prev)&(theta_prev<theta_max))&(theta_min<theta_max))
            theta_min=theta_min+2*pi;
            theta=linspace(theta_min,theta_max,100);
            prev.E(1:100)=path.center.E(i)+R*sin(theta);
            prev.N(1:100)=path.center.N(i)+R*cos(theta);
        elseif ((theta_min>theta_prev)&(theta_prev>theta_max))&(theta_min>theta_max)
            theta_max=theta_max+2*pi;
            theta=linspace(theta_min,theta_max,100);
            prev.E(1:100)=path.center.E(i)+R*sin(theta);
            prev.N(1:100)=path.center.N(i)+R*cos(theta);
        end
        
        

        % draw arc
        switch plot_type
            case 'RS'
                plot_arc(R, theta_min, theta_max-theta_min,path.center.E(i),path.center.N(i),axes_num,'--r');
            case 'SPP'
                plot_spp(R,beta,theta_min, theta_max-theta_min,path.center.E(i),path.center.N(i),axes_num,'');
        end
        type(i)='a';
    end
end

hold off

fig=axes_num;
end